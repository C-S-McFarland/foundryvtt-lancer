import { ActiveEffectDataConstructorData } from "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/data/data.mjs/activeEffectData";
import { EffectChangeData } from "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/data/data.mjs/effectChangeData";
import { LancerActor } from "../actor/lancer-actor";
import { DamageTypeChecklist, EntryType, RangeTypeChecklist, WeaponSizeChecklist, WeaponTypeChecklist } from "../enums";
import { LancerItem, LancerMECH_WEAPON } from "../item/lancer-item";

// Chassis = mech or standard npc
export type LancerEffectTarget =
  | EntryType.PILOT
  | EntryType.MECH
  | EntryType.NPC
  | EntryType.DEPLOYABLE
  | "only_drone"
  | "only_deployable"
  | "mech_and_npc";

export interface LancerActiveEffectFlags {
  lancer: {
    // If true, then this is the effect innately generated by certain categories of items, such as frames, npc classes, etc
    // These are aggressively regenerated. Do not become attached to them.
    item_innate?: boolean;

    // If true, then this is the effect derived from item bonuses
    // These are aggressively regenerated. Do not become attached to them.
    item_bonus?: boolean;

    // If specified, disable unless this
    target_type?: LancerEffectTarget;

    // The actor (uuid) this was copied from, if applicable. Regardless of the true origin, this is the nearest ancestor
    cascade_origin?: string | null;
  };
}

export interface LancerActiveEffectConstructorData extends ActiveEffectDataConstructorData {
  flags: Record<string, unknown> & LancerActiveEffectFlags;
}

export class LancerActiveEffect extends ActiveEffect {
  /* --------------------------------------------- */

  get #typedFlags(): LancerActiveEffectFlags {
    return this.data.flags as any;
  }

  /**
   * Determine whether this Active Effect is suppressed or not.
   */
  get isSuppressed(): boolean {
    // Check it's not just passing through
    return this.isPassthrough();
  }

  /**
   * Determine whether this Active Effect is present only to be passed to descendants
   */
  isPassthrough(): boolean {
    // Check right actor type
    let tf = this.#typedFlags;
    if (this.parent instanceof LancerActor && tf?.lancer?.target_type) {
      if (tf?.lancer?.target_type === "pilot" && !this.parent.is_pilot()) return true;
      if (tf?.lancer?.target_type === "deployable" && !this.parent.is_deployable()) return true;
      if (tf?.lancer?.target_type === "mech" && !(this.parent.is_mech() || this.parent.is_npc())) return true;
    }
    return false;
  }

  /* --------------------------------------------- */

  /**
   * Manage Active Effect instances through the Actor Sheet via effect control buttons
   */
  static async onManageActiveEffect(event: MouseEvent, owner: LancerActor | LancerItem) {
    event.preventDefault();
    /*
    const a = event.currentTarget;
    const li = a.closest("li");
    const effect = li.dataset.effectId ? owner.effects.get(li.dataset.effectId) : null;
    switch (a.dataset.action) {
      case "create":
        return owner.createEmbeddedDocuments("ActiveEffect", [
          {
            label: game.i18n.localize("DND5E.EffectNew"),
            icon: "icons/svg/aura.svg",
            origin: owner.uuid,
            "duration.rounds": li.dataset.effectType === "temporary" ? 1 : undefined,
            
          },
        ]);
      case "edit":
        return effect.sheet.render(true);
      case "delete":
        return effect.delete();
      case "toggle":
        return effect.update({ disabled: !effect.data.disabled });
    }
    */
  }

  /* --------------------------------------------- */

  /**
   * Prepare the data structure for Active Effects which are currently applied to an Actor or Item.
   */
  static prepareActiveEffectCategories(actor: LancerActor, effects: LancerActiveEffect[]) {
    // Define effect header categories
    const categories = {
      passive: {
        type: "passive",
        // label: game.i18n.localize("DND5E.EffectTemporary"),
        label: "Enabled",
        effects: [] as LancerActiveEffect[],
      },
      inherited: {
        type: "inherited",
        label: "Inherited",
        effects: [] as LancerActiveEffect[],
      },
      disabled: {
        type: "disabled",
        label: "Disabled",
        effects: [] as LancerActiveEffect[],
      },
      passthrough: {
        type: "passthrough",
        label: game.i18n.localize("DND5E.EffectUnavailable"),
        effects: [] as LancerActiveEffect[],
        info: [game.i18n.localize("DND5E.EffectUnavailableInfo")],
      },
    };

    // Iterate over active effects, classifying them into categories
    for (let e of effects) {
      // e._getSourceName(); // Trigger a lookup for the source name
      if (e.isPassthrough()) categories.passthrough.effects.push(e);
      else if (e.data.disabled) categories.disabled.effects.push(e);
      else if (e.#typedFlags.lancer.cascade_origin) categories.inherited.effects.push(e);
      else categories.passive.effects.push(e);
    }

    // categories.suppressed.hidden = !categories.suppressed.effects.length;
    return categories;
  }
}

// To support our effect passdown. Lie about it being a valid number type
export const AE_MODE_SET_JSON = 11 as 1;
export const AE_MODE_APPEND_JSON = 12 as 2;
Hooks.on(
  "applyActiveEffect",
  function (actor: LancerActor, change: EffectChangeData, current: any, _delta: any, _changes: any) {
    if (change.mode == AE_MODE_SET_JSON || change.mode == AE_MODE_APPEND_JSON) {
      try {
        let parsed_delta = JSON.parse(change.value);
        // Ok, now set it to wherever it was labeled
        if (change.mode == AE_MODE_SET_JSON) {
          foundry.utils.setProperty(actor.data, change.key, parsed_delta);
        } else if (change.mode == AE_MODE_APPEND_JSON) {
          foundry.utils.getProperty(actor.data, change.key).push(parsed_delta);
        }
      } catch (e) {
        // Nothing to do really, except log it
        console.warn(`Data transfer active effect corrupted, ${change.value}`);
      }
    }
  }
);
